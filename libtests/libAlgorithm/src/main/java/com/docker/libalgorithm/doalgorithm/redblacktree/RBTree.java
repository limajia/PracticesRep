package com.docker.libalgorithm.doalgorithm.redblacktree;

//红黑树 (排序树优化后的)
//红黑树中 会补充使用黑色的NIL（空结点）作为树的叶子结点
//黑色节点的（左右）子节点可以是红色的，也可以是黑色的。若红色节点，则（左右）子节点都必须是黑色节点。
/*
1.根节点是黑色的
2.每个补充的叶子结点都是黑色的NIL节点
3.红色节点，（左右）子节点都必须是黑色节点
4.从任意结点到叶子结点，包含的黑色节点个数是相同的
延伸：从根节点到叶子节点的最长的路径不多于最短的路径的长度的两倍（所以说红黑树不是严格的平衡二叉树）

hashmap-->使用红黑树

oo,二叉搜索树--优化-->平衡树二叉树---->红黑树

二叉排序树：根节点值大于树的左叶子结点值，且根节点值小于右叶子节点值
平衡二叉树：1.平衡二叉树是二叉排序树，是二叉排序树的改良版，相同序列平衡二叉树的高度小于或等于二叉排序数的
                     高度,  所以平衡二叉树的查找比二叉排序树快。但平衡二叉树的创建过程，保证二叉树平衡调整次数较多。
                     2.平衡二叉树的左右叶子结点高度差情况只能为 -1，0，1

红黑树和平衡二叉树区别如下：
1、红黑树放弃了追求完全平衡，追求大致平衡，在与平衡二叉树的时间复杂度相差不大的情况下，保证每次插入最多只需要三次旋转就能达到平衡，实现起来也更为简单。
2、平衡二叉树追求绝对平衡，条件比较苛刻，实现起来比较麻烦，每次插入新节点之后需要旋转的次数不能预知。

平衡二叉树（AVL）树是严格的平衡二叉树，平衡条件必须满足（所有节点的左右子树高度差不超过1）。不管我们是执行插入还是删除操作，
只要不满足上面的条件，就要通过旋转来保持平衡，而的英文旋转非常耗时的。所以平衡二叉树（AVL）适合用于插入与删除次数比较少，但查找多的情况。
红黑树在二叉查找树的基础上增加了着色和相关的性质使得红黑树相对平衡，从而保证了红黑树的查找、插入、删除的时间复杂度最坏为O(log
n)。所以红黑树适用于搜索，插入，删除操作较多的情况。
 */
public class RBTree {
}
